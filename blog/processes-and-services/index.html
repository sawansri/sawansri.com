<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>An Introduction to Services and Processes in Linux | Sawan Srivastava</title>
    <link rel="stylesheet" href="../../css/blog.css"> 
</head>
<body>
    <div class="container">
        <header class="main-header">
            <div class="logo"><a href="/">Sawan Srivastava</a></div>
            <nav class="main-nav">
                <ul>
                    <li><a href="/index.html">Home</a></li>
                    <li><a href="/blog.html">Blog</a></li>
                    <li><a href="/index.html#resume">Resume</a></li>
                </ul>
            </nav>
        </header>

        <main>
            <article class="post-full">
                <h1 class="post-title">An Introduction to Services and Processes in Linux</h1>
                <p class="post-meta">September 30, 2025</p>
                <div class="post-content">
                    <p>This post covers the fundamentals of services and processes in Linux as covered in Lecture 4 of the OCF Linux SysAdmin DeCal. The main goal is to help you become a more productive Linux user, not a kernel hacker.</p>

                    <hr>

                    <h2>Understanding Processes</h2>
                    <p>A process is a single instance of a running program. Processes are isolated from one another, each having its own memory and threads.</p>

		    <h3>Processes vs. Threads</h3>
			<p>A process has one or more threads.</p>
			<p>Processes have their own data and code, must use pipes, files, etc. to communicate with one another.
			Threads share the same process but have different system states (“multithreaded process”)</p>
						<img src="images/thread.png"></img>
                    <h3>What Defines a Process?</h3>
                    <p>Every process has several key identifiers and components:</p>
                    <ul class="indent-list">
                        <li><strong>PID:</strong> A unique Process ID.</li>
                        <li><strong>PPID:</strong> The Parent's Process ID.</li>
                        <li><strong>UID:</strong> The ID of the user running the process.</li>
                        <li><strong>Executable:</strong> The program that the process is running.</li>
                        <li><strong>Args:</strong> The arguments (command line) of the process (and more...)</li>
                    </ul>
                    <p>All processes are started by a parent process, with the exception of the very first one: the <strong>init process</strong>. This process is started at boot, is assigned PID 1, and serves as the ancestor for all other processes on the system.</p>

						<img src="images/htop_tree.png"></img>

                    <h3>Process Creation: The `fork()` and `exec()` System Calls</h3>
                    <p>A new process is created when an existing process calls `fork()`. This creates two processes, a parent and a child, which are nearly identical. The parent keeps its PID, while the child receives a new one. The child process can then optionally call `exec()` to replace its own program with a new one.</p>
						<img src="images/fork.png"></img>
						<br><br>
						<h3>How many henlo's get printed?</h3>
						<br><br>
						<img src="images/henlo_fork.png"></img>
                    <h3>The Process Lifecycle: Zombies and Orphans</h3>
                    <p>When a child process terminates, it becomes a <strong>zombie process</strong>. Its metadata remains in the process table so its parent can read its exit status. The parent is responsible for "reaping" the zombie by calling the `wait()` system call. If a long-running parent process fails to do this, it can cause a resource leak as zombies accumulate.</p>
						<img src="images/zombie.png"></img>
                    <p>If a parent process exits before its child, the child becomes an <strong>orphan process</strong>. Orphaned processes are immediately adopted by the init process (PID 1), which automatically reaps them when they exit, preventing them from becoming permanent zombies.</p>
						<img src="images/re-init.png"></img>

		<br><br>
			<h3>Communication</h3>
			<h4>Inter-Process Communication</h4>
			<ul class="indent-list">
				<li>Exit codes</li>
				<li>Signals (e.g. SIGTERM, SIGKILL, SIGINT)</li>
				<li>Pipes (STDIN, STDOUT, STDERR)</li>
				<li>Sockets (UNIX socket, IP socket)</li>
				<li>Message Bus (e.g. dbus on Linux)</li>
				<li>and many more...</li>
							</ul>
<h4>Process Signals</h4>
			<ul class="indent-list">
				<li>SIGTERM: tell a process to exit now</li>
				<li>SIGKILL: terminate process immediately</li>
				<li>SIGINT: interrupt, when you press Ctrl+C</li>
				<li>SIGHUP: the user closes the terminal window</li>
				<li>SIGWINCH: terminal window resized</li>
				<li>SIGSTOP / SIGCONT: stop/resume</li>
							</ul>

                    <h3>Job Control in the Shell</h3>
                    <p>Job control allows you to manage processes running in your shell. A <strong>foreground process</strong> is one attached to your shell, like an open editor or a script you're running. A <strong>background process</strong> runs without user interaction and does not block the terminal.</p>
                    <p>You can manage these jobs with a few key commands:</p>
                    <ul class="indent-list">
                        <li><strong>Ctrl+Z</strong>: Suspends the currently running foreground process by sending it a `SIGTSTP` signal.</li>
                        <li><strong>`jobs`</strong>: Lists the current jobs (suspended or in the background).</li>
                        <li><strong>`fg %jobid`</strong>: Brings a suspended or background job to the foreground.</li>
                        <li><strong>`bg %jobid`</strong>: Resumes a suspended job in the background.</li>
                        <li><strong>`command &`</strong>: Starts a command directly in the background.</li>
                    </ul>

                    <hr>

                    <h2>Services and Daemons</h2>
                    <p>A service is a special type of process known as a <strong>daemon</strong>. A daemon is a non-interactive background process designed to run for long periods. They are crucial for tasks like serving web pages (<code>nginx</code>), handling remote logins (<code>sshd</code>), or logging system events (<code>rsyslogd</code>).</p>

                    <hr>
                    
                    <h2>Managing Services with systemd</h2>
                    <p>On modern Linux systems, services are managed by an init system, most commonly <strong>systemd</strong>. The primary tool for interacting with systemd is the <code>systemctl</code> command.</p>
                    
                    <h3>Essential `systemctl` Commands</h3>
                    <p>You can control any service managed by systemd with these commands:</p>
                    <ul class="indent-list">
                        <li><code>systemctl status [name]</code>: Check the detailed status of a service.</li>
                        <li><code>systemctl start [name]</code>: Starts a service.</li>
                        <li><code>systemctl stop [name]</code>: Stops a service.</li>
                        <li><code>systemctl restart [name]</code>: Restarts a service.</li>
                        <li><code>systemctl enable [name]</code>: Sets a service to start automatically on boot.</li>
                        <li><code>systemctl disable [name]</code>: Prevents a service from starting on boot.</li>
                    </ul>
                </div>
            </article>
            <a href="/blog" class="back-link">← All Posts</a>
        </main>
    </div>
</body>
</html>
